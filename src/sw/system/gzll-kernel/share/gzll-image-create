#!/usr/bin/python

# Copyright (c) 2015 by the author(s)
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# Author(s):
#   Stefan Wallentowitz <stefan.wallentowitz@tum.de>
#   Max Koenen <koenenwmn@googlemail.com>

# Usage:

# Create a configuration file (e.g., image.ini) with the following
# format:
#
# [app0-name]
# path: app0
# tasks: <task0> <task1>
# task0.boot: 0
# task1.boot: 1
#
# <...>
#
# [appi]
# image: <appi.elf>
# tiles: <tileID>,<tileID>,...
#
# kernelsize determines the stack of the kernel
#
# Run: gzll-image-create image.ini image.bin

import ConfigParser
import sys
import subprocess
import mmap
import os

def print_usage():
    print "Usage: gzll-image-create <configuration> <outimage>"

if len(sys.argv) < 3:
    print_usage()
    exit(1)

inifile = sys.argv[1]
outimage = sys.argv[2]
debug = False
if len(sys.argv) > 3:
    if sys.argv[3] == "-d":
        debug = True

print "(I) optimsoc-build-image started with configuration %s" % inifile

conf = ConfigParser.RawConfigParser()
conf.read(inifile)

outimage_base = os.path.splitext(outimage)[0]

apps = []

for section in conf.sections():
    path = section
    if conf.has_option(section, "path"):
        path = conf.get(section, "path")
    if not conf.has_option(section, "tasks"):
        continue
    tasks = conf.get(section, "tasks").split(" ")
    boot = []
    for t in tasks:
        tboot = "%s.boot" % t
        if conf.has_option(section, tboot):
            boot.append({ t: [int(x) for x in conf.get(section, tboot).split(" ")]})

    apps.append({ "name": section, "path": path, "tasks": tasks, "boot": boot})

for a in apps:
    print "(I) Generate binary files for %s" % a["name"]
    for t in a["tasks"]:
        print "(I)   -> %s" % t
        path = "../../apps/%s/%s.elf" % (a["path"], t)
        objname = "%s_%s" % (a["name"], t)
        subprocess.call("or1k-elf-objcopy -O binary %s %s.bin" % (path, objname), shell=True)

    print "(I) Generate object files for %s" % a["name"]
    for t in a["tasks"]:
        print "(I)   -> %s" % t
        objname = "%s_%s" % (a["name"], t)
        subprocess.call("or1k-elf-objcopy --rename-section .data=.app_data -I binary -O elf32-or1k %s.bin %s_binary.o" % (objname, objname), shell=True)
        # Patch incorrect machine type
        f = open("%s_binary.o" % objname, "r+b")
        map = mmap.mmap(f.fileno(),20)
        map[19] = '\x5c'
        map.close()

print "(I) Generate application information table"
f = open("apps.c", "w")
f.write("#include <gzll-apps.h>\n\n")
for a in apps:
    for t in a["tasks"]:
        tname = "%s_%s" % (a["name"], t)
        f.write("extern void *_binary_%s_bin_start;\n" % tname);
        f.write("extern void *_binary_%s_bin_end;\n" % tname);
    f.write("\n")

    f.write("struct gzll_task gzll_%s_tasks [] = {\n" % (a["name"]))
    for t in a["tasks"]:
        tname = "%s_%s" % (a["name"], t)
        f.write("    {\"%s\", (void*) &_binary_%s_bin_start, (void*) &_binary_%s_bin_start },\n" % (t, tname, tname))
    f.write("    { 0, 0, 0 }\n")
    f.write("};\n")

f.write("\n")
f.write("struct gzll_application gzll_application_table [] = {\n")
for a in apps:
    f.write("    { \"%s\", gzll_%s_tasks },\n" % (a["name"], a["name"]))
f.write("    { 0, 0 }\n")
f.write("};\n");
f.close()

print "(I) Compile application information table"
subprocess.check_call("pkg-config --exists gzll-kernel", shell=True)
cflags = subprocess.check_output("pkg-config gzll-kernel --cflags", shell=True).strip()
subprocess.check_output("or1k-elf-gcc %s -c -o apps.o apps.c" % cflags, shell=True)

link_ld = """
OUTPUT_ARCH(or1k)

SECTIONS
{
    .vectors : {
        *(.vectors)
    }

    .kernel ALIGN(0x2000) : {
        skernel = .;
        _skernel = .;
        *(.text*)
        *(.init)
        *(.fini)
        *(.data)
        *(.rodata*)
        *(.ctors)
        *(.dtors)
        *(.eh_frame)
        *(.jcr)
        ekernel = .;
        _ekernel = .;
    }

    .apps ALIGN(0x2000): {
                _apps_begin = .;
                . = ALIGN(0x2000);
                _apps_end = .;
        }

    .bss ALIGN(0x2000): {
        __bss_start = .;
        *(.bss)
        __bss_end = .;
        *(COMMON)
        _end = .;
        end = .;
    }
}
"""

f = open("image.ld", "w")
f.write(link_ld)
f.close()

objects = []
for a in apps:
    for t in a["tasks"]:
        objects.append("%s_%s_binary.o" % (a["name"], t))


subprocess.check_call("pkg-config --exists gzll-kernel", shell=True)
kernel = subprocess.check_output("pkg-config gzll-kernel --libs", shell=True).strip()

subprocess.check_call("pkg-config --exists optimsoc-baremetal-runtime", shell=True)
runtime_libs = subprocess.check_output("pkg-config optimsoc-baremetal-runtime --libs", shell=True).strip()

subprocess.check_call("pkg-config --exists optimsoc-baremetal-mp-runtime", shell=True)
mp_libs = subprocess.check_output("pkg-config optimsoc-baremetal-mp-runtime --libs", shell=True).strip()

libs = "%s %s %s" % (kernel, mp_libs, runtime_libs)

subprocess.check_output("or1k-elf-gcc -mboard=optimsoc -Wall -T image.ld %s apps.o %s -o %s.elf" % (" ".join(objects),libs,outimage), shell=True)

subprocess.check_output("or1k-elf-objcopy -O binary %s.elf %s.bin" % (outimage, outimage), shell=True)

subprocess.check_output("bin2vmem %s.bin > %s.vmem" % (outimage, outimage), shell=True)
