#!/usr/bin/python

# Copyright (c) 2015 by the author(s)
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# Author(s):
#   Stefan Wallentowitz <stefan.wallentowitz@tum.de>
#   Max Koenen <koenenwmn@googlemail.com>

# Usage:

# Create a configuration file (e.g., image.ini) with the following
# format:
#
# [app0]
# path: app0
# tasks: task0 task1

# [app0.inst0] 
# task0: 0
# task1: 1
#
#
# Run: gzll-image-create image.ini

import ConfigParser
import sys
import subprocess
import mmap
import os

def print_usage():
    print "Usage: gzll-image-create <configuration>"
    print "       The default configuration is 'image.ini'"

inifile = "image.ini"

# Check if configuration is set
if len(sys.argv) == 2:
    inifile = sys.argv[1]

print "(I) optimsoc-build-image started with configuration %s" % inifile

conf = ConfigParser.RawConfigParser()
# read returns a list of files that were read successfully
if not inifile in conf.read(inifile):
    print "(E) Configuration cannot be read from %s" % inifile
    exit(1)

print "(I) Generate Makefile"

# Open and start Makefile
makefile = open("Makefile", "w")
makefile.write("# Automatically generated with gzll-image-create, do not edit\n\n")
makefile.write("SCRIPTDIR=$(shell pkg-config --variable=buildscriptdir optimsoc-gzll)\n\n")
makefile.write("all: image.elf image.bin image.vmem\n\n")

# Generate list of apps
appid = 0
apps = {}
for section in conf.sections():
    if "." in section:
        continue
    path = section
    if conf.has_option(section, "path"):
        path = conf.get(section, "path")
    if not conf.has_option(section, "tasks"):
        continue
    tasks = conf.get(section, "tasks").split(" ")

    app = { "path": path, "tasks": tasks, "id": appid }
    apps[section] = app
    appid = appid + 1

appinsts = []
for section in conf.sections():
    if not "." in section:
        continue

    s = section.split(".")
    app = s[0]
    inst = s[1]
    name = "%s-%s" % (app, inst)

    tinst = {}
    numinst = 0
    for o in conf.options(section):
        if o == "name":
            name = conf.get(section, "name")
        else:
            tinst[o] = [int(x) for x in conf.get(section, o).split(" ")]
            numinst = numinst + len(tinst[o])

    appinsts.append({"app": app, "inst": inst, "name": name, "taskinst": tinst, "numinst": numinst})

# Generate Makefile entries for apps
objects = []
for a in apps:
    for t in apps[a]["tasks"]:
        print "(I)   -> %s" % t
        path = "../../apps/%s/%s.elf" % (apps[a]["path"], t)
        objname = "%s_%s" % (a, t)
        objects.append({"path": path, "objname": objname})

makefile.write("APP_BINARY_OBJECTS = ")
for o in objects:
     makefile.write("%s_binary.o " % o["objname"])
makefile.write("\n")

for o in objects:
    makefile.write("%s.bin: %s\n" % (o["objname"], o["path"]))
    makefile.write("\tor1k-elf-objcopy -O binary $^ $@\n")

makefile.write("include $(SCRIPTDIR)/Makefile-images.inc\n")
makefile.close()

print "(I) Generate application information table"
f = open("apps.c", "w")
f.write("#include <gzll-apps.h>\n\n")
for a in apps:
    for t in apps[a]["tasks"]:
        tname = "%s_%s" % (a, t)
        f.write("extern void *_binary_%s_bin_start;\n" % tname);
        f.write("extern void *_binary_%s_bin_end;\n" % tname);
    f.write("\n")

    f.write("struct gzll_task_list gzll_%s_tasks = {\n" % a)
    f.write("    %d,\n" % len(apps[a]["tasks"]))
    f.write("    {\n");
    for t in apps[a]["tasks"]:
        tname = "%s_%s" % (a, t)
        f.write("        {\"%s\", (void*) &_binary_%s_bin_start, (void*) &_binary_%s_bin_end },\n" % (t, tname, tname))
    f.write("    }\n");
    f.write("};\n")

f.write("\n")
f.write("struct gzll_application_table gzll_application_table = {\n")
f.write("    %d,\n" % len(apps))
for a in apps:
    f.write("    { \"%s\", &gzll_%s_tasks },\n" % (a, a))
f.write("};\n\n");

for a in appinsts:
    f.write("struct gzll_boot_mappings gzll_boot_mappings_%s_%s = {\n" % (a["app"], a["inst"]))
    f.write("    %d, {\n" % a["numinst"])
    app = a["app"]
    for i in a["taskinst"]:
        ranks = a["taskinst"][i]
        tindex = apps[app]["tasks"].index(i)
        for r in ranks:
            f.write("    { %d, &gzll_%s_tasks.tasks[%d] },\n" % (r, app, tindex))
    f.write("    }\n")
    f.write("};\n")

f.write("\n")

f.write("struct gzll_boot_apps gzll_boot_apps = {\n");
f.write("    %d, {\n" % len(appinsts))
for a in appinsts:
    f.write("        { \"%s\", &gzll_boot_mappings_%s_%s },\n" % (a["name"], a["app"], a["inst"]))
f.write("    }\n")
f.write("};\n")

f.close()

print "(I) Done. Run 'make' to build the image."
