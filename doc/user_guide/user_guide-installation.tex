\chapter{Installation \& Configuration}
\label{chap:installation}

Before you get started with OpTiMSoC you should notice that external
tools and libraries might be required that are in some cases
proprietary and cost some money. Although OpTiMSoC is developed at an
university with access to many EDA tools, we aim to always provide
tool flows and support for open and free tools, but especially when it
comes to synthesis such alternatives are even not available.

\section{Prerequisites}

Throughout this document some packages are required in your Linux
distribution. OpTiMSoC should principally work on all common Linux
distributions. In case you encounter problems in your system we highly
encourage you to contact the OpTiMSoC maintainers to fix these
problems. Nevertheless, we recommend Ubuntu 12.04 or 14.04 LTS as
development system and can ensure OpTiMSoC will work on it as we also
work on it. In the following we will refer to Ubuntu/Debian commands
to install packages, that will run under Ubuntu 12.04 and 14.04 LTS.

Independent of the components you plan to use, you will need some
packages to be installed:

\begin{lstlisting}
sudo apt-get -y install git g++ python libtool automake autoconf \
    libusb-1.0-0-dev libreadline6-dev cmake sdcc
\end{lstlisting}

\section{Get OpTiMSoC}

OpTiMSoC does not (yet) come as an installation package, but is
distributed as a set of git\footnote{\url{http://www.git-scm.org}}
repositories. The repositories are needed for two purposes. First,
they are the installation source for tools and libraries. Second, the
hardware sources, applications etc. are contained there to create your
OpTiMSoC systems.

It is generally a good idea to understand git, especially when you
plan to contribute to OpTiMSoC. Nevertheless, we will give a more
detailed explanation of how to get your personal copies of OpTiMSoC
and (potentially) update them. To ease the entry and handling of all
the repositories, we use Google repo. It is a wrapper around git
developed for the Android development. Despite we have not employed
such a sophisticated workflow we make use of some important parts of
it, like tracking releases etc.

The steps to clone the basic OpTiMSoC environment from the server are

\begin{lstlisting}
mkdir optimsoc
cd optimsoc
wget https://storage.googleapis.com/git-repo-downloads/repo
chmod a+x repo
./repo init -u https://github.com/optimsoc/optimsoc-repo
./repo sync
\end{lstlisting}

This loads the current stable development branches. Especially when
you are new we are recommending to use releases. A release is just a
combination of commits from the repositories. You can find a list of
all releases as xml files under
\url{https://github.com/optimsoc/optimsoc-repo}. You can then
initialize all repositories to the specified release as for example
for the latest \verb|rel-current|:

\begin{lstlisting}
./repo init -u https://github.com/optimsoc/optimsoc-repo -m \
    rel-current.xml
\end{lstlisting}

As long as you don't change files from the repositories you can simply
change versions without even knowing git.

\section{Basic Environment Configuration}


You need to set the following basic environment variables (e.g., in your
\verb|.bashrc|):

\begin{lstlisting}
export OPTIMSOC=/path/to/optimsoc/
export OPTIMSOC_RTL=$OPTIMSOC/src/rtl

export LISNOC=$OPTIMSOC/external/lisnoc
export LISNOC_RTL=$LISNOC/rtl
\end{lstlisting}

With the environment variables set, you can start using OpTiMSoC.

\section{OpTiMSoC Installation Path}

As mentioned before, some parts of OpTiMSoC (libraries and tools) need
to be built and then also installed. Those are common for different
platforms you create.

You can install the files whereever you want as some environment
variables (\verb|PATH|, \verb|PKG_CONFIG_PATH|, etc.) help finding
them. Throughout this document we use the environment variable
\verb|OPTIMSOC_INSTALLATION|, which we recommend to be set to

\begin{lstlisting}
export OPTIMSOC_INSTALLATION=/opt/optimsoc
\end{lstlisting}

as installation path.

\section{OpTiMSoC Toolchain}

There are two basic toolchains. You will always need the
\emph{baremetal toolchain} (\verb|or1k-elf|) for compiling C files to
be executed on OpTiMSoC. Beside this, there is the \emph{gzll
  toolchain} (\verb|or1k-gzll|) if you want to run the gzll Kernel and
compile user space applications for it.

\subsection{Baremetal Toolchain (or1k-elf)}

In most cases you will not need to build the entire OpenRISC toolchain
from scratch, but download the pre-compiled toolchain. It is the
standard or1k-elf toolchain with multicore extension as found on
\url{https://openrisc.github.io/newlib/multicore.html}. Just download
the latest toolchain and extract it to
\verb|/opt/or1k-elf-multicore|. In case you need to use another folder
you may need to build the toolchain yourself as described on the
toolchain website.

In any case you need to add the toolchain to your path (e.g., in
\verb|~/.bashrc|):

\begin{lstlisting}
export PATH=/opt/or1k-elf-multicore/bin
\end{lstlisting}

\subsection{gzll Toolchain (or1k-gzll)}

The gzll toolchain is still work in progress and needs to be built
manually as described on the toolchain website
\url{http://www.optimsoc.org/gzll-newlib/}. Afterwards you also need
it in your environment:

\begin{lstlisting}
export PATH=$PATH:/opt/or1k-gzll/bin
\end{lstlisting}

\section{TCL Environment \& Additional Scripts}

In the EDA field TCL is still the scripting language of choice.
Fortunately, all of the EDA tools have a TCL scripting interface. To
allow for easier creation of projects and compile RTL sources we added
some TCL scripts for all modules and targets. Beside the TCL scripts
some Python scripts and utility programs are required by the OpTiMSoC
platforms.

To install the tools simply run

\begin{lstlisting}
$OPTIMSOC/tools/install.sh $OPTIMSOC_INSTALLATION
\end{lstlisting}

and then set the environment:

\begin{lstlisting}
export OPTIMSOC_TCL=$OPTIMSOC_INSTALLATION/tools/tcl
export PATH=$PATH:$OPTIMSOC_INSTALLATION/tools/utils
\end{lstlisting}

\section{System Software}

There are essential two different ways to develop software for
OpTiMSoC, either as baremetal software or using the compute node
operating system gzll. For both ways you need to compile a set of
libraries that help you developing software for OpTiMSoC.

\subsection{Baremetal Libraries}

There are a set of libraries you build in one run, most important the
baremetal drivers, some support for runtime systems (scheduler,
virtual memory) and message passing support. The installation consist
of the libraries themselves and build infrastructure for your
applications.

The baremetal libraries are hosted at
\url{https://github.com/optimsoc/baremetal-libraries}. You need this
repository and the \verb|or1k-elf| toolchain in your path to build and
install the libraries. The repository is part of the repo tree.

%Autotools are used to check your platform and generate the configure
%and the Makefiles:

%\begin{lstlisting}
%$> ./autogen.sh
%\end{lstlisting}

%The rest of the installation is straight forward.

To perform the installation run:

\begin{lstlisting}
mkdir build
cd build
../configure --prefix=$OPTIMSOC_INSTALLATION/sw/ --host=or1k-elf
make
make install
\end{lstlisting}

\subsection{gzll Kernel and Libraries}

If you plan to write applications on top of our gzll operating system,
you need to compile the kernel and the userspace libraries.

\subsubsection{Kernel}

The kernel is hosted in the repository
\url{https://github.com/optimsoc/gzll}. In the repo-managed tree it is
found at \verb|src/sw/gzll|. Go there and run

\begin{lstlisting}
./autogen.sh
mkdir build; cd build
../configure --prefix=${OPTIMSOC_INSTALLATION}/sw --host=or1k-elf
make
sudo make install
\end{lstlisting}

\subsubsection{Userspace Libraries}

For your userspace application you will need the libraries. Build and
install them (be sure you have \verb|or1k-gzll-gcc| in your path!)

\begin{lstlisting}
./autogen.sh
mkdir build; cd build;
../configure --prefix=${OPTIMSOC_INSTALLATION}/sw --host=or1k-gzll
make
sudo make install
\end{lstlisting}

\subsection{Configuration}

After you installed the librariees you need to enable them in your
system. When you followed the steps above you will have to add the
environment variables as (example for bash):

\begin{lstlisting}
export PKG_CONFIG_PATH=$OPTIMSOC_INSTALLATION/sw/share/pkgconfig
export PATH=$OPTIMSOC_INSTALLATION/sw/bin:$PATH
\end{lstlisting}

\section{Host Software}

The host software allows you to communicate with the system for
control and debugging/diagnosis. \verb|liboptimsochost| is the basic
library, which also has a command line interface. A graphical user
interface complements this for easier visualization of the system. All
communication between the target and the host is done by a generic communication
library called ``GLIP''.

Before you start, set the \verb|PKG_CONFIG_PATH| for the host software, which
will contain the glip and liboptimsochost pkgconfig files.

\begin{lstlisting}
export PKG_CONFIG_PATH=$OPTIMSOC_INSTALLATION/host/lib/pkgconfig:$PKG_CONFIG_PATH
\end{lstlisting}

\subsection{GLIP}

GLIP is an independent project and the sources need to be obtained separately
from OpTiMSoC.

\begin{lstlisting}
git clone https://github.com/tum-lis/glip.git
cd glip
./autogen.sh
mkdir build
cd build
../configure --enable-cypressfx2 --enable-tcp --prefix=$OPTIMSOC_INSTALLATION/host
make
make install
\end{lstlisting}

\subsection{liboptimsochost}

The library is found in the repository at
\url{https://github.com/optimsoc/host} (repo tree \verb|src/host|) in
\verb|liboptimsochost|.  Some tools are included with the library, the
most important is the command line interface \verb|optimsoc_cli|. It
can be used to communicate with the OpTiMSoC debug system on the
command line. Recently, a Python scripting interface has been
added. You will need the python development libraries for this to work
when enabled via \verb|--enable-python-interface|.

Build, make and install:

\begin{lstlisting}
mkdir build
cd build
../configure --prefix=$OPTIMSOC_INSTALLATION/host --enable-python-interface
make
make install
\end{lstlisting}

Before proceeding you will need to set the correct paths:

\begin{lstlisting}
export LD_LIBRARY_PATH=$OPTIMSOC_INSTALLATION/host/lib:$LD_LIBRARY_PATH
export PATH=$OPTIMSOC_INSTALLATION/host/bin:$PATH
\end{lstlisting}

\subsection{Graphical User Interface}

\subsubsection{Prerequisites}

For building you will need Qt:

\begin{lstlisting}
sudo apt-get install libqt4-dev
\end{lstlisting}

In case you want to develop the GUI, install qtcreator:

\begin{lstlisting}
sudo apt-get install qtcreator
\end{lstlisting}

\subsubsection{Building}

The graphical user interface resides in \verb|optimsocgui| in the host
repository. We use cmake here as it better integrates with the Qt
toolchain (which is used for the GUI).

To build it:

\begin{lstlisting}
mkdir build
cd build
cmake -DCMAKE_INSTALL_PREFIX:PATH=$OPTIMSOC_INSTALLATION/host ..
make
make install
\end{lstlisting}

Afterwards add the path

\begin{lstlisting}
export PATH=$PATH:$OPTIMSOC_INSTALLATION/host/bin
\end{lstlisting}

\section{ZTEX Tools}

In case you are running the bitstreams on the ZTEX FPGAs (and only
then) you will need the ZTEX toolchain as it can be downloaded at
\url{http://www.ztex.de}. We will in the following assume you
downloaded it and unpacked it to \verb|/opt/ztex/| so that the folder
\verb|/opt/ztex/java| exists. You will need to set the path
accordingly:

\begin{lstlisting}
export PATH=/opt/ztex/bin:/opt/ztex/java/FWLoader:$PATH
\end{lstlisting}

Furthermore you will need the small device compiler \verb|sdcc|.

\section{SystemC, Verilator and SystemC Libraries}

SystemC\footnote{\url{http://www.systemc.org}} is used as simulation
library for both full system simulation based on Verilator and in
future for abstracted simulations. In case you want to use either of
them, you will therefore need to download, compile and install
SystemC.

In case you want to run the Verilator-based simulation examples or
develop software using the Verilator-based simulation, you will need
to download and compile Verilator too.

In the following the installation to \verb|/opt| is assumed, change
the folder if necessary.

\subsection{SystemC}

In case you already have SystemC installed (e.g., in the latest
version 2.3.1), you simply need to set the \verb|PKG_CONFIG_PATH|
properly to where the \verb|systemc.pc| file is found. In the latest
version this is for example:

\begin{lstlisting}
export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:$SYSTEMC/lib-linux64/pkgconfig
\end{lstlisting}

If you don't have SystemC installed, please download the SystemC
package (\verb|systemc-2.3.1.tgz|) from
\url{http://accellera.org/downloads/standards/systemc}. Extract the
file and go to the folder \texttt{systemc-2.3.1}. Build and install
SystemC (we use \texttt{/opt/systemc} here).

\begin{lstlisting}
mkdir build
cd build
../configure --prefix=/opt/systemc
make
sudo make install
\end{lstlisting}

You will now find SystemC in \verb|/opt/systemc| and need to set
\verb|PKG_CONFIG_PATH| as described above:

\begin{lstlisting}
export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/opt/systemc/lib-linux64/pkgconfig
\end{lstlisting}

\subsection{Verilator}

Verilator is part of Debian/Ubuntu-based distributions nowadays and it
should work fine from the repositories. Unfortunately, it just
recently creates a pkgconfig file and there is a steady deveopment
although regarding the performance. So we recommend building the most
recent version, which is actually quite straigt forward.

\begin{lstlisting}
git clone http://git.veripool.org/git/verilator
autoconf
./configure
make
sudo make install
\end{lstlisting}

This will install Verilator to /usr/local. Your system should usually
find the binary and pkgconfig file.

\subsection{OpTiMSoC SystemC library}

The OpTiMSoC SystemC library contains SystemC modules for debugging of
Verilator simulations and other. It can be found in the repository at
\url{https://github.com/optimsoc/systemc} or in \texttt{src/systemc}
in the repo. The build is identical to the other libraries

\begin{lstlisting}
./autogen.sh
mkdir build
cd build
../configure --prefix=$OPTIMSOC_INSTALLATION/systemc
make
sudo make install
\end{lstlisting}

When SystemC is not found, make sure \verb|PKG_CONFIG_PATH| is
correctly set.

\subsection{Configuration}

You will need the following environment variables (e.g., in bash):

\begin{lstlisting}[language=bash]
# SystemC environment
export SYSTEMC=/opt/systemc
export PKG_CONFIG_PATH=$SYSTEMC/lib-linux64/pkgconfig:$PKG_CONFIG_PATH
export LD_LIBRARY_PATH=$SYSTEMC/lib-linux64
export PKG_CONFIG_PATH=${OPTIMSOC_INSTALLATION}/systemc/share/pkgconfig:$PKG_CONFIG_PATH
export LD_LIBRARY_PATH=${OPTIMSOC_INSTALLATION}/systemc/lib/:$LD_LIBRARY_PATH
\end{lstlisting}

\section{Configuration Summary}

Check that you have the following environment variables set at this
point (or a subset depending on your requirements):

\begin{lstlisting}[language=bash]
export OPTIMSOC=/path/to/optimsoc/repo/tree
export OPTIMSOC_RTL=${OPTIMSOC}/src/rtl

export LISNOC=$OPTIMSOC/external/lisnoc
export LISNOC_RTL=$LISNOC/rtl

# Your OpTiMSoC installation path
export OPTIMSOC_INSTALLATION=/opt/optimsoc

# Baremetal toolchain
export PATH=/opt/or1k-elf/bin:$PATH

# TCL scripting
export OPTIMSOC_TCL=$OPTIMSOC_INSTALLATION/tools/tcl

# SystemC environment
export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:$SYSTEMC/lib-linux64/pkgconfig
export LD_LIBRARY_PATH=$SYSTEMC/lib-linux64
export PKG_CONFIG_PATH=${OPTIMSOC_INSTALLATION}/systemc/share/pkgconfig:$PKG_CONFIG_PATH
export LD_LIBRARY_PATH=${OPTIMSOC_INSTALLATION}/systemc/lib/:$LD_LIBRARY_PATH

# System software
export PKG_CONFIG_PATH=$OPTIMSOC_INSTALLATION/sw/share/pkgconfig:$PKG_CONFIG_PATH
export PATH=$OPTIMSOC_INSTALLATION/sw/bin:$PATH

# Host library, tools and GUI
export PKG_CONFIG_PATH=$OPTIMSOC_INSTALLATION/host/lib/pkgconfig:$PKG_CONFIG_PATH
export LD_LIBRARY_PATH=$OPTIMSOC_INSTALLATION/host/lib:$LD_LIBRARY_PATH
export PATH=$OPTIMSOC_INSTALLATION/host/bin:$PATH
\end{lstlisting}

